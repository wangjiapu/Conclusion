

## TCP三次握手和四次挥手的全过程

三次握手：

第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。
四次挥手

四次握手:

第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。

第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。

第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。

第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。


## TCP的传输策略

当我们使用TCP来发送数据的时候，TCP是使用数据包的方式来发送的，但是当数据包混乱我们是没有办法的，所以我们为了能够是数据包可靠的，顺序的收到，采用了流控技术

也就是窗口控制来保证数据包的到达有序．

## TCP的拥塞控制

解决网络的拥塞，真正的解决办法是减慢数据率

而拥塞检测是非常困难的，所以我们就假设所有的请求超时是因为拥塞造成的．

在TCP中使用的拥塞控制算法就是慢启动算法：

发送的数据包从１开始发送，然后在超时之前收到了请求回应，那么就将这个数据包的大小翻倍，依次类推，但是这个值不能一直按照指数爆炸式的方式增长，最后我设置了一个阀值，当
数据包的大小达到，这个阀值的时候就利用线性的增长率增长，第一次遇到请求超时的时候，立刻将阀值将为之前的一半，然后重新开启慢启动，就这样一次类推．

还有快速回复：当请求超时的时候，我们不是将最初的数据包设为一，而是使用阀值的大小开始线性增长

## 定时器

出现定时器的原因有好多，比如，当刚才提到的如果拥塞窗口的大小为０时候　就会发送一个窗口为０的消息　另一个就会等待窗口不为０的消息到来，然后去发送下一个，
但是如果窗口不为０的消息发送回来的途中丢失了，这样就会造成死锁

这就需要的一个确认计时器


计时器的出现就是为了避免数据包的多次重发而造成的拥塞．
